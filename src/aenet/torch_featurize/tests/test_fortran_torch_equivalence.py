"""
Cross-validation test comparing Fortran and PyTorch HDF5 outputs.

This test validates that TorchAUCFeaturizer produces HDF5 files that are
numerically equivalent to those generated by the Fortran-based
AenetAUCFeaturizer.
"""

import os
import shutil
import tempfile

import numpy as np
import pytest

from aenet import config
from aenet.featurize import AenetAUCFeaturizer
from aenet.formats.xsf import XSFParser
from aenet.geometry import AtomicStructure
from aenet.torch_featurize import TorchAUCFeaturizer
from aenet.trainset import TrnSet


# Check if Fortran tools are available
def fortran_tools_available():
    """Check if aenet Fortran executables are configured."""
    try:
        aenet_paths = config.read('aenet')
        generate_x_exists = os.path.exists(
            aenet_paths.get('generate_x_path', '')
        )
        trnset2ascii_x_exists = os.path.exists(
            aenet_paths.get('trnset2ascii_x_path', '')
        )
        return generate_x_exists and trnset2ascii_x_exists
    except Exception:
        return False


# Skip tests if Fortran not available
pytestmark = pytest.mark.skipif(
    not fortran_tools_available(),
    reason="Fortran executables (generate.x and trnset2ASCII.x) not available"
)


@pytest.fixture
def temp_dir():
    """Create temporary directory for test files."""
    tmpdir = tempfile.mkdtemp()
    yield tmpdir
    shutil.rmtree(tmpdir)


@pytest.fixture
def water_structure():
    """Create water molecule structure."""
    positions = np.array([
        [0.000, 0.000, 0.118],  # O
        [0.000, 0.755, -0.471],  # H
        [0.000, -0.755, -0.471]  # H
    ])
    species = ['O', 'H', 'H']
    energy = -15.5
    forces = np.array([
        [0.0, 0.0, 0.1],
        [0.0, 0.1, -0.05],
        [0.0, -0.1, -0.05]
    ])

    return AtomicStructure(
        coords=positions,
        types=species,
        energy=energy,
        forces=forces
    )


@pytest.fixture
def lmnto_structures():
    """Create multi-species LMNTO crystal structures."""
    # Simple cubic supercell with mixed elements
    positions1 = np.array([
        [0.0, 0.0, 0.0],    # Li
        [2.0, 0.0, 0.0],    # Mo
        [0.0, 2.0, 0.0],    # Ni
        [2.0, 2.0, 0.0],    # Ti
        [0.0, 0.0, 2.0],    # O
        [2.0, 0.0, 2.0],    # O
        [0.0, 2.0, 2.0],    # O
        [2.0, 2.0, 2.0],    # O
    ])
    species1 = ['Li', 'Mo', 'Ni', 'Ti', 'O', 'O', 'O', 'O']
    avec = np.array([
        [4.0, 0.0, 0.0],
        [0.0, 4.0, 0.0],
        [0.0, 0.0, 4.0]
    ])
    energy1 = -85.3
    forces1 = 0.1 * np.random.randn(8, 3)

    struc1 = AtomicStructure(
        coords=positions1,
        types=species1,
        avec=avec,
        energy=energy1,
        forces=forces1
    )

    # Second structure with different positions
    positions2 = positions1 + 0.05 * np.random.randn(*positions1.shape)
    energy2 = -85.1
    forces2 = 0.1 * np.random.randn(8, 3)

    struc2 = AtomicStructure(
        coords=positions2,
        types=species1,
        avec=avec,
        energy=energy2,
        forces=forces2
    )

    return [struc1, struc2]


class TestFortranTorchEquivalence:
    """Test that Fortran and PyTorch produce equivalent HDF5 files."""

    def test_water_molecule_equivalence(self, temp_dir, water_structure):
        """Test equivalence for simple water molecule."""
        # Create XSF file
        xsf_file = os.path.join(temp_dir, 'water.xsf')
        xsf_parser = XSFParser()
        xsf_parser.write(water_structure, xsf_file)

        # Featurization parameters
        typenames = ['O', 'H']
        rad_order = 10
        rad_cutoff = 4.0
        ang_order = 3
        ang_cutoff = 1.5
        atomic_energies = {'O': -10.0, 'H': -2.5}

        # Fortran-based featurization
        fortran_fzer = AenetAUCFeaturizer(
            typenames=typenames,
            rad_order=rad_order,
            rad_cutoff=rad_cutoff,
            ang_order=ang_order,
            ang_cutoff=ang_cutoff
        )
        fortran_h5 = os.path.join(temp_dir, 'features_fortran.h5')
        fortran_fzer.run_aenet_generate(
            xsf_files=[xsf_file],
            hdf5_filename=fortran_h5,
            atomic_energies=atomic_energies
        )

        # PyTorch-based featurization
        torch_fzer = TorchAUCFeaturizer(
            typenames=typenames,
            rad_order=rad_order,
            rad_cutoff=rad_cutoff,
            ang_order=ang_order,
            ang_cutoff=ang_cutoff
        )
        torch_h5 = os.path.join(temp_dir, 'features_torch.h5')
        torch_fzer.run_aenet_generate(
            xsf_files=[xsf_file],
            hdf5_filename=torch_h5,
            atomic_energies=atomic_energies
        )

        # Compare HDF5 files
        self._compare_hdf5_files(fortran_h5, torch_h5)

    def test_lmnto_crystal_equivalence(self, temp_dir, lmnto_structures):
        """Test equivalence for multi-species LMNTO crystals."""
        # Create XSF files
        xsf_files = []
        for i, struc in enumerate(lmnto_structures):
            xsf_file = os.path.join(temp_dir, f'lmnto_{i}.xsf')
            xsf_parser = XSFParser()
            xsf_parser.write(struc, xsf_file)
            xsf_files.append(xsf_file)

        # Featurization parameters
        typenames = ['Li', 'Mo', 'Ni', 'Ti', 'O']
        rad_order = 10
        rad_cutoff = 4.0
        ang_order = 3
        ang_cutoff = 1.5
        atomic_energies = {
            'Li': -2.52,
            'Mo': -0.63,
            'Ni': -2.20,
            'Ti': -2.20,
            'O': -10.08
        }

        # Fortran-based featurization
        fortran_fzer = AenetAUCFeaturizer(
            typenames=typenames,
            rad_order=rad_order,
            rad_cutoff=rad_cutoff,
            ang_order=ang_order,
            ang_cutoff=ang_cutoff
        )
        fortran_h5 = os.path.join(temp_dir, 'features_fortran.h5')
        fortran_fzer.run_aenet_generate(
            xsf_files=xsf_files,
            hdf5_filename=fortran_h5,
            atomic_energies=atomic_energies
        )

        # PyTorch-based featurization
        torch_fzer = TorchAUCFeaturizer(
            typenames=typenames,
            rad_order=rad_order,
            rad_cutoff=rad_cutoff,
            ang_order=ang_order,
            ang_cutoff=ang_cutoff
        )
        torch_h5 = os.path.join(temp_dir, 'features_torch.h5')
        torch_fzer.run_aenet_generate(
            xsf_files=xsf_files,
            hdf5_filename=torch_h5,
            atomic_energies=atomic_energies
        )

        # Compare HDF5 files
        self._compare_hdf5_files(fortran_h5, torch_h5)

    def _compare_hdf5_files(self, fortran_h5, torch_h5):
        """
        Compare two HDF5 files for numerical equivalence.

        Args:
            fortran_h5: Path to Fortran-generated HDF5 file
            torch_h5: Path to PyTorch-generated HDF5 file
        """
        with TrnSet.from_file(fortran_h5) as ts_fortran, \
             TrnSet.from_file(torch_h5) as ts_torch:

            # Compare metadata
            print("\nComparing metadata...")
            assert ts_fortran.num_structures == ts_torch.num_structures
            assert ts_fortran.num_atoms_tot == ts_torch.num_atoms_tot
            assert ts_fortran.num_types == ts_torch.num_types
            assert ts_fortran.atom_types == ts_torch.atom_types

            # Compare atomic energies
            np.testing.assert_allclose(
                ts_fortran.atomic_energy,
                ts_torch.atomic_energy,
                rtol=1e-14, atol=1e-14,
                err_msg="Atomic energies differ"
            )

            # Compare energy statistics
            np.testing.assert_allclose(
                ts_fortran.E_min, ts_torch.E_min,
                rtol=1e-14, atol=1e-14,
                err_msg="E_min differs"
            )
            np.testing.assert_allclose(
                ts_fortran.E_max, ts_torch.E_max,
                rtol=1e-14, atol=1e-14,
                err_msg="E_max differs"
            )
            np.testing.assert_allclose(
                ts_fortran.E_av, ts_torch.E_av,
                rtol=1e-14, atol=1e-14,
                err_msg="E_av differs"
            )

            print("Metadata matches âœ“")

            # Compare each structure
            n_structures = ts_fortran.num_structures
            print(f"\nComparing {n_structures} structures...")
            for i in range(ts_fortran.num_structures):
                fortran_struc = ts_fortran.read_structure(
                    i, read_coords=True, read_forces=True
                )
                torch_struc = ts_torch.read_structure(
                    i, read_coords=True, read_forces=True
                )

                # Compare number of atoms
                assert fortran_struc.num_atoms == torch_struc.num_atoms

                # Compare energies
                np.testing.assert_allclose(
                    fortran_struc.energy,
                    torch_struc.energy,
                    rtol=1e-14, atol=1e-14,
                    err_msg=f"Energy differs for structure {i}"
                )

                # Compare atomic data - Note: coordinates may differ due to
                # differences between Fortran xsflib and Python XSFParser,
                # especially for periodic images. What matters for ML is that
                # features match.
                for j in range(fortran_struc.num_atoms):
                    f_atom = fortran_struc.atoms[j]
                    t_atom = torch_struc.atoms[j]

                    # Compare species
                    assert f_atom['type'] == t_atom['type'], \
                        f"Species differ for atom {j} in structure {i}"

                    # Compare features (MOST IMPORTANT for ML!)
                    np.testing.assert_allclose(
                        f_atom['fingerprint'],
                        t_atom['fingerprint'],
                        rtol=1e-12, atol=1e-14,
                        err_msg=(
                            f"Features differ for atom {j} in structure {i}"
                        )
                    )

                n_atoms = fortran_struc.num_atoms
                print(f"  Structure {i}: {n_atoms} atoms âœ“")

            print("\nAll structures match!")
            msg = "Fortran and PyTorch implementations are equivalent âœ“"
            print(msg)


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
