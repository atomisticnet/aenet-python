"""
Handling input and output files for/from aenets 'train.x' tool.

"""

import re

import numpy as np
import pandas as pd

import matplotlib.pyplot as plt

from .. import config as cfg

__author__ = "Nongnuch Artrith, Alexander Urban"
__email__ = "aenet@atomistic.net"
__date__ = "2021-02-17"
__version__ = "0.1"


class TrainOutput(object):
    """
    Parser and representation of output files generated by 'train.x'.
    """

    def __init__(self, path):
        self.path = path
        self.errors = self._read_training_errors()

    def __str__(self):
        out = "Training statistics:\n"
        for k, v in self.stats.items():
            out += "  {}: {}\n".format(k, v)
        return out

    def _read_training_errors(self, path=None):
        """ Read errors from 'train.x' output file. """
        if path is None:
            path = self.path
        errors = []
        with open(path) as fp:
            for line in fp:
                if re.match("^ *[0-9].*<$", line):
                    errors.append([float(a) for a in line.split()[1:-1]])
        errors = np.array(errors)
        return pd.DataFrame(
            data=errors,
            columns=['MAE_train', 'RMSE_train', 'MAE_test', 'RMSE_test'])

    @property
    def stats(self):
        """ Return a dictionary with training statistics. """
        stats = {
            'final_MAE_train': self.errors['MAE_train'].values[-1],
            'final_RMSE_train': self.errors['RMSE_train'].values[-1],
            'final_MAE_test': self.errors['MAE_test'].values[-1],
            'final_RMSE_test': self.errors['RMSE_test'].values[-1],
            'min_RMSE_test': np.min(self.errors['RMSE_test'].values),
            'epoch_min_RMSE_test': int(
                np.argmin(self.errors['RMSE_test'].values)) + 1
        }
        return stats

    def plot_training_errors(self, pd=None, outfile=None):
        plt.rcParams.update(cfg.read('matplotlib_rc_params'))
        if pd is None:
            pd = self.errors
        pd.plot(y=["RMSE_train", "RMSE_test"], logy=True,
                xlabel="Epoch", ylabel="RMSE (eV/atom)")
        if outfile is not None:
            plt.savefig(outfile, bbox_inches='tight')
        plt.show()


class Energies(object):
    """
    Parser and representation of 'energies.train.*' and
    'energies.test.*' files, also generated by 'train.x'.

    """

    def __init__(self, path_train, path_test=None):
        self.path_train = path_train
        self.path_test = path_test
        # self.energies_train = pd.read_csv(path_train, sep="\s+")
        with open(path_train) as fp:
            columns = fp.readline()
        columns = columns.replace("Cost Func", "Cost-Func")
        columns = columns.split()[1:]
        self.energies_train = pd.read_csv(path_train,
                                          sep=r'\s+',
                                          skiprows=1, header=0,
                                          names=columns)
        if path_test is not None:
            self.energies_test = pd.read_csv(path_test,
                                             sep=r'\s+',
                                             skiprows=1, header=0,
                                             names=columns)
        else:
            self.energies_test = None

    def __str__(self):
        return

    def plot_correlation(self, outfile=None, E_min=None, E_max=None):
        plt.rcParams.update(cfg.read('matplotlib_rc_params'))
        fig = plt.figure()
        ax = fig.add_subplot(111)
        ax.set_aspect('equal', adjustable='box')
        plt.scatter(self.energies_train["ANN(eV/atom)"].values,
                    self.energies_train["Ref(eV/atom)"].values,
                    label="Training Set")
        if self.energies_test is not None:
            plt.scatter(self.energies_test["ANN(eV/atom)"].values,
                        self.energies_test["Ref(eV/atom)"].values,
                        label="Validation Set")
        x0 = np.min(self.energies_train["Ref(eV/atom)"].values)
        x1 = np.max(self.energies_train["Ref(eV/atom)"].values)
        if E_min is not None:
            x0 = E_min
        if E_max is not None:
            x1 = E_max
        x = np.linspace(x0, x1, 100)
        plt.plot(x, x, color="black", label="")
        plt.xlim([x0, x1])
        plt.ylim([x0, x1])
        plt.xlabel("ANN (eV/atom)")
        plt.ylabel("Reference (eV/atom)")
        plt.legend(loc="upper left")
        if outfile is not None:
            plt.savefig(outfile, bbox_inches='tight')
        plt.show()
