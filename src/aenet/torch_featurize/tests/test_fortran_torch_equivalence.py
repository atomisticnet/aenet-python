"""
Cross-validation test comparing Fortran and PyTorch HDF5 outputs.

This test validates that TorchAUCFeaturizer produces HDF5 files that are
numerically equivalent to those generated by the Fortran-based
AenetAUCFeaturizer.
"""

import os

import numpy as np
import pytest

from aenet import config
from aenet.featurize import AenetAUCFeaturizer
from aenet.formats.xsf import XSFParser
from aenet.geometry import AtomicStructure
from aenet.torch_featurize import TorchAUCFeaturizer
from aenet.trainset import TrnSet


# Check if Fortran tools are available
def fortran_tools_available():
    """Check if aenet Fortran executables are configured."""
    try:
        aenet_paths = config.read('aenet')
        generate_x_exists = os.path.exists(
            aenet_paths.get('generate_x_path', '')
        )
        trnset2ascii_x_exists = os.path.exists(
            aenet_paths.get('trnset2ascii_x_path', '')
        )
        return generate_x_exists and trnset2ascii_x_exists
    except Exception:
        return False


# Skip tests if Fortran not available
pytestmark = pytest.mark.skipif(
    not fortran_tools_available(),
    reason="Fortran executables (generate.x and trnset2ASCII.x) not available"
)


@pytest.fixture
def water_structure():
    """Create water molecule structure."""
    positions = np.array([
        [0.000, 0.000, 0.118],  # O
        [0.000, 0.755, -0.471],  # H
        [0.000, -0.755, -0.471]  # H
    ])
    species = ['O', 'H', 'H']
    energy = -15.5
    forces = np.array([
        [0.0, 0.0, 0.1],
        [0.0, 0.1, -0.05],
        [0.0, -0.1, -0.05]
    ])

    return AtomicStructure(
        coords=positions,
        types=species,
        energy=energy,
        forces=forces
    )


@pytest.fixture
def lmnto_structures():
    """Create multi-species LMNTO crystal structures."""
    # Simple cubic supercell with mixed elements
    positions1 = np.array([
        [0.0, 0.0, 0.0],    # Li
        [2.0, 0.0, 0.0],    # Mo
        [0.0, 2.0, 0.0],    # Ni
        [2.0, 2.0, 0.0],    # Ti
        [0.0, 0.0, 2.0],    # O
        [2.0, 0.0, 2.0],    # O
        [0.0, 2.0, 2.0],    # O
        [2.0, 2.0, 2.0],    # O
    ])
    species1 = ['Li', 'Mo', 'Ni', 'Ti', 'O', 'O', 'O', 'O']
    avec = np.array([
        [4.0, 0.0, 0.0],
        [0.0, 4.0, 0.0],
        [0.0, 0.0, 4.0]
    ])
    energy1 = -85.3
    forces1 = 0.1 * np.random.randn(8, 3)

    struc1 = AtomicStructure(
        coords=positions1,
        types=species1,
        avec=avec,
        energy=energy1,
        forces=forces1
    )

    # Second structure with different positions
    positions2 = positions1 + 0.05 * np.random.randn(*positions1.shape)
    energy2 = -85.1
    forces2 = 0.1 * np.random.randn(8, 3)

    struc2 = AtomicStructure(
        coords=positions2,
        types=species1,
        avec=avec,
        energy=energy2,
        forces=forces2
    )

    return [struc1, struc2]


class TestFortranTorchEquivalence:
    """Test that Fortran and PyTorch produce equivalent HDF5 files."""

    def test_water_molecule_equivalence(
            self, tmp_path, water_structure, monkeypatch):
        """Test equivalence for simple water molecule."""
        # Change to temp directory to contain any tmp* directories
        # created by featurize
        monkeypatch.chdir(tmp_path)
        temp_dir = str(tmp_path)

        # Create XSF file
        xsf_file = os.path.join(temp_dir, 'water.xsf')
        xsf_parser = XSFParser()
        xsf_parser.write(water_structure, xsf_file)

        # Featurization parameters
        typenames = ['O', 'H']
        rad_order = 10
        rad_cutoff = 4.0
        ang_order = 3
        ang_cutoff = 1.5
        atomic_energies = {'O': -10.0, 'H': -2.5}

        # Fortran-based featurization
        fortran_fzer = AenetAUCFeaturizer(
            typenames=typenames,
            rad_order=rad_order,
            rad_cutoff=rad_cutoff,
            ang_order=ang_order,
            ang_cutoff=ang_cutoff
        )
        fortran_h5 = os.path.join(temp_dir, 'features_fortran.h5')
        fortran_fzer.run_aenet_generate(
            xsf_files=[xsf_file],
            hdf5_filename=fortran_h5,
            atomic_energies=atomic_energies
        )

        # PyTorch-based featurization
        torch_fzer = TorchAUCFeaturizer(
            typenames=typenames,
            rad_order=rad_order,
            rad_cutoff=rad_cutoff,
            ang_order=ang_order,
            ang_cutoff=ang_cutoff
        )
        torch_h5 = os.path.join(temp_dir, 'features_torch.h5')
        torch_fzer.run_aenet_generate(
            xsf_files=[xsf_file],
            hdf5_filename=torch_h5,
            atomic_energies=atomic_energies
        )

        # Compare HDF5 files
        self._compare_hdf5_files(fortran_h5, torch_h5)

    def test_lmnto_crystal_equivalence(
            self, tmp_path, lmnto_structures, monkeypatch):
        """Test equivalence for multi-species LMNTO crystals."""
        # Change to temp directory to contain any tmp* directories
        # created by featurize
        monkeypatch.chdir(tmp_path)
        temp_dir = str(tmp_path)

        # Create XSF files
        xsf_files = []
        for i, struc in enumerate(lmnto_structures):
            xsf_file = os.path.join(temp_dir, f'lmnto_{i}.xsf')
            xsf_parser = XSFParser()
            xsf_parser.write(struc, xsf_file)
            xsf_files.append(xsf_file)

        # Featurization parameters
        typenames = ['Li', 'Mo', 'Ni', 'Ti', 'O']
        rad_order = 10
        rad_cutoff = 4.0
        ang_order = 3
        ang_cutoff = 1.5
        atomic_energies = {
            'Li': -2.52,
            'Mo': -0.63,
            'Ni': -2.20,
            'Ti': -2.20,
            'O': -10.08
        }

        # Fortran-based featurization
        fortran_fzer = AenetAUCFeaturizer(
            typenames=typenames,
            rad_order=rad_order,
            rad_cutoff=rad_cutoff,
            ang_order=ang_order,
            ang_cutoff=ang_cutoff
        )
        fortran_h5 = os.path.join(temp_dir, 'features_fortran.h5')
        fortran_fzer.run_aenet_generate(
            xsf_files=xsf_files,
            hdf5_filename=fortran_h5,
            atomic_energies=atomic_energies
        )

        # PyTorch-based featurization
        torch_fzer = TorchAUCFeaturizer(
            typenames=typenames,
            rad_order=rad_order,
            rad_cutoff=rad_cutoff,
            ang_order=ang_order,
            ang_cutoff=ang_cutoff
        )
        torch_h5 = os.path.join(temp_dir, 'features_torch.h5')
        torch_fzer.run_aenet_generate(
            xsf_files=xsf_files,
            hdf5_filename=torch_h5,
            atomic_energies=atomic_energies
        )

        # Compare HDF5 files
        self._compare_hdf5_files(fortran_h5, torch_h5)

    def _compare_hdf5_files(self, fortran_h5, torch_h5):
        """
        Compare two HDF5 files for numerical equivalence.

        Args:
            fortran_h5: Path to Fortran-generated HDF5 file
            torch_h5: Path to PyTorch-generated HDF5 file
        """
        with TrnSet.from_file(fortran_h5) as ts_fortran, \
             TrnSet.from_file(torch_h5) as ts_torch:

            # Compare metadata
            print("\nComparing metadata...")
            assert ts_fortran.num_structures == ts_torch.num_structures
            assert ts_fortran.num_atoms_tot == ts_torch.num_atoms_tot
            assert ts_fortran.num_types == ts_torch.num_types
            assert ts_fortran.atom_types == ts_torch.atom_types

            # Compare atomic energies
            np.testing.assert_allclose(
                ts_fortran.atomic_energy,
                ts_torch.atomic_energy,
                rtol=1e-14, atol=1e-14,
                err_msg="Atomic energies differ"
            )

            # Compare energy statistics
            np.testing.assert_allclose(
                ts_fortran.E_min, ts_torch.E_min,
                rtol=1e-14, atol=1e-14,
                err_msg="E_min differs"
            )
            np.testing.assert_allclose(
                ts_fortran.E_max, ts_torch.E_max,
                rtol=1e-14, atol=1e-14,
                err_msg="E_max differs"
            )
            np.testing.assert_allclose(
                ts_fortran.E_av, ts_torch.E_av,
                rtol=1e-14, atol=1e-14,
                err_msg="E_av differs"
            )

            print("Metadata matches ✓")

            # Compare each structure
            n_structures = ts_fortran.num_structures
            print(f"\nComparing {n_structures} structures...")
            for i in range(ts_fortran.num_structures):
                fortran_struc = ts_fortran.read_structure(
                    i, read_coords=True, read_forces=True
                )
                torch_struc = ts_torch.read_structure(
                    i, read_coords=True, read_forces=True
                )

                # Compare number of atoms
                assert fortran_struc.num_atoms == torch_struc.num_atoms

                # Compare energies
                np.testing.assert_allclose(
                    fortran_struc.energy,
                    torch_struc.energy,
                    rtol=1e-14, atol=1e-14,
                    err_msg=f"Energy differs for structure {i}"
                )

                # Compare atomic data - Note: coordinates may differ due to
                # differences between Fortran xsflib and Python XSFParser,
                # especially for periodic images. What matters for ML is that
                # features match.
                for j in range(fortran_struc.num_atoms):
                    f_atom = fortran_struc.atoms[j]
                    t_atom = torch_struc.atoms[j]

                    # Compare species
                    assert f_atom['type'] == t_atom['type'], \
                        f"Species differ for atom {j} in structure {i}"

                    # Compare features (MOST IMPORTANT for ML!)
                    np.testing.assert_allclose(
                        f_atom['fingerprint'],
                        t_atom['fingerprint'],
                        rtol=1e-12, atol=1e-14,
                        err_msg=(
                            f"Features differ for atom {j} in structure {i}"
                        )
                    )

                n_atoms = fortran_struc.num_atoms
                print(f"  Structure {i}: {n_atoms} atoms ✓")

            print("\nAll structures match!")
            msg = "Fortran and PyTorch implementations are equivalent ✓"
            print(msg)


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
