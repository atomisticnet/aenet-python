"""
Output file handling for aenet's `predict.x` tool.

"""

from typing import List
import numpy as np
import os
import re

__author__ = "The aenet developers"
__email__ = "aenet@atomistic.net"
__date__ = "2025-10-31"
__version__ = "0.2"


class PredictOut(object):
    """
    Parser and representation of output files generated by 'predict.x'.

    Attributes
    ----------
    coords : List[np.ndarray]
        Cartesian coordinates for each structure.
    forces : List[np.ndarray]
        Atomic forces for each structure (if computed).
    atom_types : List[np.ndarray]
        Atomic species symbols for each structure.
    atom_energies : List[np.ndarray]
        Atomic energies for each structure (if computed).
    cohesive_energy : List[float]
        Cohesive energies in eV/atom for each structure.
    total_energy : List[float]
        Total energies in eV for each structure.
    inputs : PredictIn or None
        Associated input configuration if predict_in_path was provided.
    """

    def __init__(self, coords, forces, atom_types, atom_energies,
                 cohesive_energy, total_energy, structure_paths=None,
                 timing=None):
        self.coords = coords
        self.forces = forces
        self.atom_types = atom_types
        self.atom_energies = atom_energies
        self.cohesive_energy = cohesive_energy
        self.total_energy = total_energy
        self.structure_paths = structure_paths
        self.timing = timing

    def __str__(self):
        out = f"PredictOut with {self.num_structures} structure(s)\n"
        for i in range(self.num_structures):
            n_atoms = self.num_atoms(i)
            out += f"  Structure {i}: {n_atoms} atoms, "
            out += f"E_tot = {self.total_energy[i]:.3f} eV "
            out += f"= {self.total_energy[i]/n_atoms:.3f} eV/atom\n"
        return out

    def _repr_markdown_(self):
        return self.__str__().replace('\n', '  \n')

    @property
    def paths(self):
        """List of structure file paths (if available)."""
        return self.structure_paths

    @property
    def num_structures(self):
        """Number of structures in the results."""
        return len(self.cohesive_energy)

    def num_atoms(self, i):
        """Number of atoms in structure i."""
        return len(self.atom_types[i])

    @property
    def total_energy_per_atom(self):
        """Total energy per atom for each structure."""
        return np.array([self.total_energy[i]/self.num_atoms(i)
                         for i in range(self.num_structures)])

    @property
    def cohesive_energy_per_atom(self):
        """Cohesive energy per atom for each structure."""
        return np.array([self.cohesive_energy[i]/self.num_atoms(i)
                         for i in range(self.num_structures)])

    def to_structures(self):
        """
        Convert predictions to AtomicStructure objects with energies
        and forces.

        Returns
        -------
        List[AtomicStructure]
            List of structures with energy and force labels.

        Raises
        ------
        ValueError
            If structure paths are not available.
        """
        from ..io.structure import read as read_structure

        if self.paths is None:
            raise ValueError(
                "Structure paths not available. "
                "Cannot reconstruct structures.")

        structures = []
        for i, path in enumerate(self.paths):
            struc = read_structure(path)
            # Add energy and forces as the latest snapshot
            struc.energy.append(self.total_energy[i])
            struc.forces.append(self.forces[i])
            structures.append(struc)

        return structures

    @classmethod
    def from_file(cls, filename: os.PathLike, structure_paths=None):
        """
        Parse a predict.x output file.

        Parameters
        ----------
        filename : os.PathLike
            Path to the predict.out file.
        structure_paths : List[str], optional
            List of paths to the structure files for later reconstruction.

        Returns
        -------
        PredictOut
            Parsed prediction results.
        """
        if not os.path.exists(filename):
            raise FileNotFoundError("File not found: {}".format(filename))

        coords = []
        forces = []
        atom_energies = []
        atom_types = []
        cohesive_energy = []
        total_energy = []

        with open(filename) as fp:
            line = "\n"
            while line != '':
                line = fp.readline()
                if re.match(r'^ Cartesian atomic coordinates.*', line):
                    for i in range(5):
                        line = fp.readline()
                    coords_here = []
                    forces_here = []
                    atom_energies_here = []
                    types_here = []
                    while len(line.strip()) > 0:
                        fields = line.strip().split()
                        types_here.append(fields[0])
                        coords_here.append([float(a) for a in fields[1:4]])
                        if len(fields) >= 4:
                            forces_here.append([float(a) for a in fields[4:7]])
                        else:
                            forces_here.append([])
                        if len(fields) == 5:
                            atom_energies_here.append(float(fields[4]))
                        elif len(fields) == 8:
                            atom_energies_here.append(float(fields[7]))
                        else:
                            atom_energies_here.append(float('nan'))
                        line = fp.readline()
                    atom_types.append(np.array(types_here))
                    coords.append(np.array(coords_here))
                    forces.append(np.array(forces_here))
                    atom_energies.append(np.array(atom_energies_here))
                elif m := re.match(
                        r'^ *Cohesive energy *: *([0-9.-]*) eV.*$', line):
                    cohesive_energy.append(float(m.groups()[0]))
                elif m := re.match(
                        r'^ *Total energy *: *([0-9.-]*) eV.*$', line):
                    total_energy.append(float(m.groups()[0]))

        return cls(coords=coords, forces=forces, atom_types=atom_types,
                   atom_energies=atom_energies,
                   cohesive_energy=cohesive_energy,
                   total_energy=total_energy,
                   structure_paths=structure_paths)


class PredictOutAnalyzer(object):
    """
    Analyzer for ensemble predictions from multiple predict.x runs.

    This class is useful for uncertainty quantification when predictions
    are made using an ensemble of neural network potentials.

    Parameters
    ----------
    pout_list : List[PredictOut]
        List of PredictOut objects from different ensemble members.
    """

    def __init__(self, pout_list: List[PredictOut]):
        self.pouts = pout_list
        if not self._check_compatible():
            raise ValueError("The 'predict.out' files are not compatible.")

    def __str__(self):
        out = f"PredictOutAnalyzer with {len(self.pouts)} ensemble members\n"
        out += f"Analyzing {self.num_structures} structure(s)\n"
        return out

    @property
    def num_structures(self):
        """Number of structures analyzed."""
        return self.pouts[0].num_structures

    @property
    def paths(self):
        """Paths to structure files."""
        return self.pouts[0].paths

    def num_atoms(self, i):
        """Number of atoms in structure i."""
        return self.pouts[0].num_atoms(i)

    def structure(self, i, frmt=None, **kwargs):
        """Get structure i as an AtomicStructure object."""
        from ..io.structure import read as read_structure
        return read_structure(self.paths[i], frmt=frmt, **kwargs)

    def write_pdb_with_force_uncertainty(self, i, filename, frmt=None,
                                         **kwargs):
        """
        Write structure with force uncertainty as atom attributes.

        Parameters
        ----------
        i : int
            Structure index.
        filename : str
            Output file path.
        frmt : str, optional
            Output format.
        """
        from ..io.structure import write as write_structure
        struc = self.structure(i)
        force_u = self.force_uncertainty(i)
        write_structure(struc, filename=filename, frmt=frmt,
                        atom_attrib=force_u, **kwargs)

    def energy_stats(self, i: int, normalize: bool = True):
        """
        Compute energy statistics across ensemble for structure i.

        Parameters
        ----------
        i : int
            Structure index.
        normalize : bool, optional
            If True, normalize by number of atoms. Default: True.

        Returns
        -------
        tuple
            (E_min, E_max, E_avg, E_std) energy statistics.
        """
        energies = np.array([po.total_energy[i] for po in self.pouts])
        if normalize:
            energies /= self.num_atoms(i)
        E_min = np.min(energies)
        E_max = np.max(energies)
        E_avg = np.mean(energies)
        E_std = np.std(energies)
        return E_min, E_max, E_avg, E_std

    def all_energy_stats(self, **kwargs):
        """
        Compute energy statistics for all structures.

        Returns
        -------
        tuple
            (data, columns) where data is np.ndarray of statistics and
            columns is the list of column names.
        """
        data = []
        for i in range(self.num_structures):
            data.append(self.energy_stats(i, **kwargs))
        columns = ['E_min', 'E_max', 'E_mean', 'E_std']
        return np.array(data), columns

    def force_stats(self, i: int):
        """
        Compute force standard deviation across ensemble for structure i.

        Parameters
        ----------
        i : int
            Structure index.

        Returns
        -------
        np.ndarray
            Standard deviation of forces with shape (n_atoms, 3).
        """
        forces = [po.forces[i] for po in self.pouts]
        return np.std(forces, axis=0)

    def force_uncertainty(self, i: int):
        """
        Compute per-atom force uncertainty for structure i.

        Parameters
        ----------
        i : int
            Structure index.

        Returns
        -------
        np.ndarray
            Mean force uncertainty per atom (scalar per atom).
        """
        forces = [po.forces[i] for po in self.pouts]
        return np.mean(np.std(forces, axis=0), axis=1)

    def _check_compatible(self):
        """Check if all PredictOut objects are compatible."""
        if not all([po.num_structures == self.pouts[0].num_structures
                    for po in self.pouts[1:]]):
            return False
        if all(po.paths is not None for po in self.pouts):
            paths0 = self.pouts[0].paths
            for po in self.pouts[1:]:
                if not all([po.paths[i] == paths0[i]
                            for i in range(len(paths0))]):
                    return False
        return True
